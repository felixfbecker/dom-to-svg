import { svgNamespace, isSVGImageElement, isSVGStyleElement, xlinkNamespace } from './dom'
import { fetchAsDataURL as defaultFetchAsDataURL } from './inline'
import { walkNode } from './traversal'
import { createStackingLayers } from './stacking'
import { createIdGenerator, withTimeout } from './util'
import { isCSSFontFaceRule, parseFontFaceSourceUrls } from './css'

export interface DomToSvgOptions {
	/**
	 * To visual area to contrain the SVG too.
	 * Elements that do not intersect the capture area are not included in the SVG.
	 */
	captureArea?: DOMRectReadOnly
}

export function documentToSVG(document: Document, options?: DomToSvgOptions): XMLDocument {
	return elementToSVG(document.documentElement, options)
}

export function elementToSVG(element: Element, options?: DomToSvgOptions): XMLDocument {
	const svgDocument = element.ownerDocument.implementation.createDocument(svgNamespace, 'svg', null) as XMLDocument

	const svgElement = (svgDocument.documentElement as unknown) as SVGSVGElement
	svgElement.setAttribute('xmlns', svgNamespace)
	svgElement.setAttribute('xmlns:xlink', xlinkNamespace)
	svgElement.append(
		svgDocument.createComment(` Generated by dom-to-svg from ${element.ownerDocument.location.href} `)
	)

	// Copy @font-face rules
	const styleElement = svgDocument.createElementNS(svgNamespace, 'style')
	for (const styleSheet of element.ownerDocument.styleSheets) {
		let rules: CSSRuleList | undefined
		try {
			rules = styleSheet.rules
		} catch (error) {
			console.error('Could not access rules of styleSheet', styleSheet, error)
		}
		for (const rule of rules ?? []) {
			if (isCSSFontFaceRule(rule)) {
				const styleSheetHref = rule.parentStyleSheet?.href
				if (styleSheetHref) {
					rule.style.src = parseFontFaceSourceUrls(rule.style.src)
						.map(source =>
							'url' in source ? { ...source, url: new URL(source.url, styleSheetHref) } : source
						)
						.map(source => {
							if ('url' in source) {
								return `url(${source.url.href})` + (source.format ? ` format(${source.format})` : '')
							}
							return `local(${source.local})`
						})
						.join(', ')
				}
				styleElement.append(rule.cssText, '\n')
			}
		}
	}
	svgElement.append(styleElement)

	walkNode(element, {
		svgDocument,
		currentSvgParent: svgElement,
		stackingLayers: createStackingLayers(svgElement),
		parentStackingLayer: svgElement,
		getUniqueId: createIdGenerator(),
		labels: new Map(),
		captureArea: options?.captureArea ?? element.getBoundingClientRect(),
	})

	const bounds = options?.captureArea ?? element.getBoundingClientRect()
	svgElement.setAttribute('width', bounds.width.toString())
	svgElement.setAttribute('height', bounds.height.toString())
	svgElement.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`)

	return svgDocument
}

declare global {
	interface SVGStyleElement extends LinkStyle {}
}

export interface InlineResourcesOptions {
	fetchAsDataURL?: (url: string) => Promise<URL>
}

export async function inlineResources(element: Element, options: InlineResourcesOptions = {}): Promise<void> {
	const { fetchAsDataURL = defaultFetchAsDataURL } = options
	if (isSVGImageElement(element)) {
		const dataURL = await withTimeout(5000, `Timeout fetching ${element.href.baseVal}`, () =>
			fetchAsDataURL(element.href.baseVal)
		)
		element.dataset.src = element.href.baseVal
		element.setAttribute('href', dataURL.href)
	} else if (isSVGStyleElement(element) && element.sheet) {
		try {
			const rules = element.sheet.cssRules
			for (const rule of rules) {
				if (isCSSFontFaceRule(rule)) {
					const sources = parseFontFaceSourceUrls(rule.style.src)
					const resolvedSources = await Promise.all(
						sources.map(async source => {
							if (!('url' in source)) {
								return source
							}
							const dataUrl = await withTimeout(5000, `Timeout fetching ${source.url}`, () =>
								fetchAsDataURL(source.url)
							)
							return { ...source, url: dataUrl }
						})
					)
					rule.style.src = resolvedSources
						.map(source => {
							if ('local' in source) {
								return source.local
							}
							return [`url(${source.url.href})`, source.format && `format(${source.format})`]
								.filter(Boolean)
								.join(' ')
						})
						.join(', ')
				}
			}
		} catch (error) {
			console.error('Error inlining stylesheet', element.sheet, error)
		}
	}
	await Promise.all([...element.children].map(element => inlineResources(element, options)))
}

export { fetchAsDataURL } from './inline'
